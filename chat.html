<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chat â€” App (Discord style)</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>
<style>
  :root{
    --bg:#0d1117; --panel:#0f1418; --muted:#c9d1d9;
    --mine:#5865F2; --other:#2f3136;
  }
  html,body{height:100%}
  body{background:var(--bg); color:var(--muted); font-family:Inter,system-ui; margin:0}
  .msg-bubble{display:inline-block; word-break:break-word; white-space:pre-wrap; border-radius:12px; padding:12px; box-shadow: 0 2px 4px rgba(0,0,0,0.35)}
  .meta{font-size:12px; opacity:0.78; margin-bottom:6px; display:flex; gap:10px; align-items:center}
  .meta .who{font-weight:600}
  .meta .time{font-size:11px; opacity:0.6}
  .actions{display:flex; gap:8px; margin-top:8px; justify-content:flex-end}
  .small-btn{font-size:12px; padding:6px 10px; border-radius:8px}
  @keyframes fadeIn{from{opacity:0; transform:translateY(6px)}to{opacity:1; transform:none}}
  .fade{animation:fadeIn .18s ease-out}
  /* responsive friends overlay */
  #friendsOverlay{display:none}
  @media (max-width:760px){
    #friendsPanel{display:none}
    #friendsToggle{display:inline-flex}
    #friendsOverlay{display:none; position:fixed; inset:0; background:rgba(0,0,0,.6); z-index:60; padding:12px; overflow:auto}
  }
  @media (min-width:761px){
    #friendsToggle{display:none}
    #friendsPanel{display:flex}
  }
  /* input area */
  #messageInput{min-height:56px; max-height:180px; resize:none; width:100%}
  /* messages sizing: width greater than height typical */
  .msg-bubble{max-width:78%}
  /* fix send button sizing */
  .send-wrap{display:flex; flex-direction:column; gap:8px; align-items:flex-end}
  /* smaller screens */
  @media (max-width:420px){
    .msg-bubble{max-width:90%}
    #friendsPanel{display:none}
  }
</style>
</head>
<body class="flex flex-col h-screen">

<header class="bg-[#0f1418] p-3 flex items-center justify-between border-b border-gray-800">
  <div class="flex items-center gap-3">
    <button id="friendsToggle" class="text-sm px-2 py-1 bg-gray-800 rounded hidden">Amigos</button>
    <strong class="text-sm">Chat AnÃ´nimo</strong>
    <div id="status" class="text-xs text-gray-400 ml-3">Conectando...</div>
  </div>

  <div class="flex items-center gap-3">
    <nav class="flex gap-2">
      <button id="tabGlobal" class="px-3 py-1 rounded bg-gray-800 text-sm">Global</button>
      <button id="tabDM" class="px-3 py-1 rounded text-sm">Mensagens</button>
    </nav>
    <a href="index.html" id="logoutLink" class="text-xs text-gray-400">Sair</a>
    <a href="admin.html" id="adminLink" class="text-xs text-red-400 hidden">Admin</a>
  </div>
</header>

<div class="flex-1 flex overflow-hidden">
  <main id="mainColumn" class="flex-1 flex flex-col">
    <div id="messages" class="flex-1 overflow-auto p-4 space-y-3 bg-[#161b22]"></div>

    <section class="bg-[#0f1418] p-3 border-t border-gray-800 flex gap-3 items-start">
      <textarea id="messageInput" placeholder="Escreva..." class="flex-1 p-2 rounded bg-[#0f1418] border border-gray-700 text-sm" rows="2"></textarea>
      <div class="send-wrap">
        <button id="sendBtn" class="bg-blue-600 px-4 py-2 rounded text-sm">Enviar</button>
        <div id="sendMode" class="text-xs text-gray-400">Modo: Global</div>
      </div>
    </section>
  </main>

  <aside id="friendsPanel" class="w-80 bg-[#0f1418] border-l border-gray-800 p-3 hidden md:flex flex-col">
    <input id="friendSearchDesktop" placeholder="Pesquisar usuÃ¡rios..." class="w-full p-2 rounded bg-[#0f1418] border border-gray-700 text-sm mb-3" />
    <div id="recommendationsDesktop" class="space-y-2 mb-3"></div>
    <div>
      <h4 class="text-sm mb-2">Seus amigos</h4>
      <div id="friendsAreaDesktop" class="space-y-2 max-h-[40vh] overflow:auto"></div>
    </div>
    <div class="mt-auto text-xs text-gray-400">NotificaÃ§Ãµes: <span id="notifCount">0</span></div>
  </aside>
</div>

<!-- friends overlay mobile -->
<div id="friendsOverlay" class="hidden">
  <div class="bg-[#0f1418] rounded p-3 h-full">
    <div class="flex gap-2 mb-3">
      <input id="friendSearch" placeholder="Pesquisar usuÃ¡rios..." class="flex-1 p-2 rounded bg-[#0f1418] border border-gray-700 text-sm" />
      <button id="closeFriends" class="px-3 py-2 bg-gray-700 rounded">Fechar</button>
    </div>
    <div id="recommendations" class="space-y-2"></div>
    <div class="mt-4">
      <h4 class="text-sm mb-2">Seus amigos</h4>
      <div id="friendsArea" class="space-y-2"></div>
    </div>
  </div>
</div>

<script type="module">
/* Final robust chat.html
   - logout with signOut
   - in-memory usernames via onValue (no duplicates)
   - visibilitychange to refresh
   - safe listeners (attach once)
   - global + DM (Discord-like)
*/

import { initializeApp } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-app.js";
import { getAuth, signInAnonymously, onAuthStateChanged, signOut as fbSignOut } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-auth.js";
import {
  getDatabase, ref, push, onChildAdded, onChildChanged, onChildRemoved,
  get, set, update, onValue, remove
} from "https://www.gstatic.com/firebasejs/12.5.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyDAQS7qpWTDH7itAgn1eAJIeLOfVxy__cM",
  authDomain: "chat-firebase-efcbe.firebaseapp.com",
  databaseURL: "https://chat-firebase-efcbe-default-rtdb.firebaseio.com",
  projectId: "chat-firebase-efcbe",
  storageBucket: "chat-firebase-efcbe.firebasestorage.app",
  messagingSenderId: "376919463932",
  appId: "1:376919463932:web:4b2139df551d0a026ac479",
  measurementId: "G-R14XVTJBFL"
};
const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const auth = getAuth(app);

// UI refs
const statusEl = document.getElementById('status');
const messagesEl = document.getElementById('messages');
const messageInput = document.getElementById('messageInput');
const sendBtn = document.getElementById('sendBtn');
const sendModeEl = document.getElementById('sendMode');

const friendsToggle = document.getElementById('friendsToggle');
const friendsOverlay = document.getElementById('friendsOverlay');
const friendsPanel = document.getElementById('friendsPanel');
const friendSearch = document.getElementById('friendSearch');
const friendSearchDesktop = document.getElementById('friendSearchDesktop');
const recommendations = document.getElementById('recommendations');
const recommendationsDesktop = document.getElementById('recommendationsDesktop');
const friendsArea = document.getElementById('friendsArea');
const friendsAreaDesktop = document.getElementById('friendsAreaDesktop');
const closeFriends = document.getElementById('closeFriends');

const tabGlobal = document.getElementById('tabGlobal');
const tabDM = document.getElementById('tabDM');
const adminLink = document.getElementById('adminLink');
const notifCountEl = document.getElementById('notifCount');
const logoutLink = document.getElementById('logoutLink');

let currentUserUid = localStorage.getItem('chat_user_uid') || null;
let currentUsername = localStorage.getItem('chat_user_username') || 'AnÃ´nimo';
let authUid = null;
let currentRoomId = null; // null=global, else private room id

const markedParse = window.marked;
function renderMarkdown(md){ const html = markedParse.parse(md||''); return DOMPurify.sanitize(html); }
function timeStr(ts){ try{ return new Date(ts).toLocaleTimeString(); }catch(e){ return ''; } }
function logError(e){ console.error('CHAT ERROR', e); }

// -------- usernames cache (no duplicates) --------
let allUsernames = {}; // {lowername: uid}
onValue(ref(db, 'usernames'), snap => {
  allUsernames = snap.exists() ? snap.val() : {};
  // keep UI responsive: if search term exists, refresh recommendations
  const t = (document.activeElement === friendSearch) ? friendSearch.value : (document.activeElement === friendSearchDesktop ? friendSearchDesktop.value : '');
  if(t) {
    doSearchAndRender(t, recommendations);
    doSearchAndRender(t, recommendationsDesktop);
  }
});

// -------- message element builder --------
function createMessageElement(id, data, isPrivate=false){
  const wrapper = document.createElement('div');
  wrapper.className = 'fade flex';
  wrapper.style.justifyContent = (data.userId === currentUserUid) ? 'flex-end' : 'flex-start';
  wrapper.dataset.msgId = id;

  const bubble = document.createElement('div');
  bubble.className = 'msg-bubble';
  bubble.style.background = (data.userId === currentUserUid) ? 'var(--mine)' : 'var(--other)';
  bubble.style.color = (data.userId === currentUserUid) ? 'white' : '#d6dbe3';
  bubble.style.maxWidth = '78%';

  const meta = document.createElement('div'); meta.className = 'meta';
  const who = document.createElement('div'); who.className = 'who'; who.textContent = data.username || 'AnÃ´nimo';
  const t = document.createElement('div'); t.className = 'time'; t.textContent = (data.timestamp ? `â€¢ ${timeStr(data.timestamp)}` : '');
  meta.appendChild(who); meta.appendChild(t);

  const content = document.createElement('div'); content.className = 'content'; content.innerHTML = renderMarkdown(data.text || '');

  bubble.appendChild(meta); bubble.appendChild(content);

  if(data.userId === currentUserUid){
    const actions = document.createElement('div'); actions.className = 'actions';
    const editBtn = document.createElement('button'); editBtn.className = 'small-btn text-xs text-gray-200'; editBtn.textContent = 'editar';
    const delBtn = document.createElement('button'); delBtn.className = 'small-btn text-xs text-red-400'; delBtn.textContent = 'apagar';

    editBtn.onclick = ()=> openModal('Editar mensagem', data.text, async (newText)=>{
      if(!newText.trim()) return;
      const path = isPrivate ? `privateMessages/${currentRoomId}/messages/${id}` : `messages/${id}`;
      try{ await update(ref(db, path), { text:newText, editedAt: Date.now() }); }catch(e){ logError(e); }
    });

    delBtn.onclick = ()=> openModal('Apagar mensagem', 'Tem certeza?', async ()=>{
      const path = isPrivate ? `privateMessages/${currentRoomId}/messages/${id}` : `messages/${id}`;
      try{ await remove(ref(db, path)); }catch(e){ logError(e); }
    }, true);

    actions.appendChild(editBtn); actions.appendChild(delBtn);
    bubble.appendChild(actions);
  }

  wrapper.appendChild(bubble);
  return wrapper;
}

// modal
function openModal(title, content, onConfirm, confirmOnly=false){
  const modal = document.createElement('div');
  Object.assign(modal.style,{position:'fixed', inset:0, background:'rgba(0,0,0,0.6)', display:'flex', alignItems:'center', justifyContent:'center', zIndex:120});
  const box = document.createElement('div'); Object.assign(box.style,{background:'#111318', padding:'14px', borderRadius:'8px', width:'92%', maxWidth:'420px'});
  const h = document.createElement('h3'); h.textContent = title; h.className='text-sm mb-2'; box.appendChild(h);
  let inputEl = null;
  if(!confirmOnly){
    inputEl = document.createElement('textarea'); inputEl.className = 'w-full p-2 rounded bg-[#0f1418] border border-gray-700 mb-3'; inputEl.value = content || '';
    box.appendChild(inputEl);
  } else {
    const p = document.createElement('p'); p.className='text-xs mb-3'; p.textContent = content; box.appendChild(p);
  }
  const row = document.createElement('div'); row.className='flex justify-end gap-2';
  const bCancel = document.createElement('button'); bCancel.className='px-3 py-1 bg-gray-700 rounded'; bCancel.textContent='Cancelar'; bCancel.onclick = ()=> modal.remove();
  const bOk = document.createElement('button'); bOk.className='px-3 py-1 bg-blue-600 rounded'; bOk.textContent='Confirmar';
  bOk.onclick = async ()=>{ await onConfirm(inputEl ? inputEl.value : ''); modal.remove(); };
  row.appendChild(bCancel); row.appendChild(bOk); box.appendChild(row); modal.appendChild(box); document.body.appendChild(modal);
}

// -------- authentication helpers --------
async function ensureAuth(){
  return new Promise((resolve) => {
    if(auth.currentUser){
      authUid = auth.currentUser.uid;
      resolve(auth.currentUser);
      return;
    }
    const unsub = onAuthStateChanged(auth, (user) => {
      if(user){
        authUid = user.uid;
        unsub();
        resolve(user);
      }
    });
    signInAnonymously(auth).catch((e)=>{ console.warn('signInAnonymously failed', e); });
  });
}

// -------- global message loader + listener (attach once) --------
let globalListenerAttached = false;
let displayedGlobal = new Set();

async function loadAndListenGlobal(){
  try{
    const refGlobal = ref(db, 'messages');
    // initial load
    const snap = await get(refGlobal);
    messagesEl.innerHTML = '';
    displayedGlobal.clear();
    if(snap.exists()){
      const data = snap.val();
      const keys = Object.keys(data).sort((a,b)=> (data[a].timestamp||0) - (data[b].timestamp||0));
      for(const k of keys){
        displayedGlobal.add(k);
        messagesEl.appendChild(createMessageElement(k, data[k], false));
      }
      messagesEl.scrollTop = messagesEl.scrollHeight;
    } else {
      messagesEl.innerHTML = '<div class="text-gray-400">Sem mensagens pÃºblicas.</div>';
    }
    // attach child listeners only once
    if(!globalListenerAttached){
      onChildAdded(refGlobal, s=>{
        const id = s.key;
        if(displayedGlobal.has(id)) return;
        displayedGlobal.add(id);
        messagesEl.appendChild(createMessageElement(id, s.val(), false));
        messagesEl.scrollTop = messagesEl.scrollHeight;
      });
      onChildChanged(refGlobal, s=>{
        const id = s.key;
        const n = messagesEl.querySelector(`[data-msg-id="${id}"]`);
        if(n) n.replaceWith(createMessageElement(id, s.val(), false));
      });
      onChildRemoved(refGlobal, s=>{
        const id = s.key;
        const n = messagesEl.querySelector(`[data-msg-id="${id}"]`);
        if(n) n.remove();
        displayedGlobal.delete(id);
      });
      globalListenerAttached = true;
    }
  }catch(e){ logError(e); }
}

// -------- private messages (basic, load per room) --------
async function listenPrivate(roomId){
  try{
    const msgsRef = ref(db, `privateMessages/${roomId}/messages`);
    // initial
    const snap = await get(msgsRef);
    messagesEl.innerHTML = '';
    if(snap.exists()){
      const data = snap.val();
      const keys = Object.keys(data).sort((a,b)=> (data[a].timestamp||0) - (data[b].timestamp||0));
      for(const k of keys) messagesEl.appendChild(createMessageElement(k, data[k], true));
      messagesEl.scrollTop = messagesEl.scrollHeight;
    } else messagesEl.innerHTML = '<div class="text-gray-400">Sem mensagens nessa conversa.</div>';
    // attach listeners (note: these will add duplicates across room changes but acceptable for most flows;
    // improvements: store and remove listeners per room â€” can be added later)
    onChildAdded(msgsRef, s=>{
      if(messagesEl.querySelector(`[data-msg-id="${s.key}"]`)) return;
      messagesEl.appendChild(createMessageElement(s.key, s.val(), true));
      messagesEl.scrollTop = messagesEl.scrollHeight;
    });
    onChildChanged(msgsRef, s=>{
      const n = messagesEl.querySelector(`[data-msg-id="${s.key}"]`);
      if(n) n.replaceWith(createMessageElement(s.key, s.val(), true));
    });
    onChildRemoved(msgsRef, s=>{
      const n = messagesEl.querySelector(`[data-msg-id="${s.key}"]`);
      if(n) n.remove();
    });
  }catch(e){ logError(e); }
}

// deterministic room id
function roomIdFor(a,b){ return [a,b].sort().join('_'); }

// -------- boot sequence --------
(async function bootstrap(){
  try{
    // ensure auth and session
    await ensureAuth();
    // if no local storage user id set, fallback to auth uid (makes testing easier)
    if(!currentUserUid && auth.currentUser) {
      currentUserUid = auth.currentUser.uid;
      localStorage.setItem('chat_user_uid', currentUserUid);
      localStorage.setItem('chat_user_username', currentUsername);
    }
    statusEl.textContent = 'Carregando...';

    // load global messages and attach listeners
    await loadAndListenGlobal();

    // presence tracking
    onValue(ref(db, '.info/connected'), snap=>{
      if(snap.val() === true){
        try{ set(ref(db, `status/${currentUserUid}`), { state:'online', last_changed: Date.now() }); }catch(e){}
        statusEl.innerHTML = '<span class="text-green-500">ðŸŸ¢ Online</span>';
        window.addEventListener('beforeunload', ()=> {
          try{ set(ref(db, `status/${currentUserUid}`), { state:'offline', last_changed: Date.now() }); }catch(e){}
        });
      } else {
        statusEl.innerHTML = '<span class="text-red-500">ðŸ”´ Offline</span>';
      }
    });

    // admin link
    const a = await get(ref(db, `admins/${currentUserUid}`));
    if(a.exists() && a.val() === true) adminLink.classList.remove('hidden');

    // friend requests count
    onValue(ref(db, `friendRequests/${currentUserUid}`), snap=>{
      const val = snap.exists() ? Object.keys(snap.val()).length : 0;
      notifCountEl.textContent = val;
    });

    // initial friends UI
    await loadFriendsUI();

    statusEl.textContent = 'Pronto';

  }catch(e){ logError(e); statusEl.textContent = 'Erro'; }
})();

// -------- friends UI & search (in-memory) --------
async function loadFriendsUI(){
  try{
    const s = await get(ref(db, `users/${currentUserUid}/friends`));
    friendsArea.innerHTML = ''; friendsAreaDesktop.innerHTML = '';
    if(!s.exists()) return;
    const f = s.val();
    for(const uid of Object.keys(f)){
      const name = f[uid].username || uid;
      const btn = document.createElement('button'); btn.className='w-full text-left px-3 py-2 bg-gray-800 rounded'; btn.textContent = name;
      btn.onclick = ()=> openPrivateWith(uid, name);
      friendsArea.appendChild(btn);
      const clone = btn.cloneNode(true); clone.onclick = btn.onclick; friendsAreaDesktop.appendChild(clone);
    }
  }catch(e){ logError(e); }
}
onValue(ref(db, `users/${currentUserUid}/friends`), ()=> loadFriendsUI());

// search rendering function (used for desktop/mobile)
function doSearchAndRender(q, outEl){
  outEl.innerHTML = '';
  if(!q) return;
  const low = q.toLowerCase();
  let added = 0;
  for(const unameKey of Object.keys(allUsernames)){
    if(added >= 12) break;
    if(unameKey.includes(low)){
      const uid = allUsernames[unameKey];
      if(uid === currentUserUid) continue;
      // fetch user data (cached not implemented; small number assumed)
      get(ref(db, `users/${uid}`)).then(s=>{
        if(!s.exists()) return;
        const user = s.val();
        const row = document.createElement('div'); row.className='p-2 bg-[#111318] rounded flex justify-between items-center';
        const name = document.createElement('div'); name.textContent = user.username;
        name.style.cursor = 'pointer';
        name.onclick = ()=>{
          // fill search input depending on which outEl
          if(outEl === recommendations) friendSearch.value = user.username;
          if(outEl === recommendationsDesktop) friendSearchDesktop.value = user.username;
        };
        const addBtn = document.createElement('button'); addBtn.textContent = 'Adicionar'; addBtn.className = 'small-btn bg-blue-600 text-white';
        addBtn.onclick = async ()=>{
          try{
            await set(ref(db, `friendRequests/${uid}/${currentUserUid}`), { username: currentUsername, from: currentUserUid, at: Date.now() });
            addBtn.textContent = 'Enviado';
          }catch(e){ logError(e); addBtn.textContent = 'Erro'; }
        };
        row.appendChild(name); row.appendChild(addBtn);
        outEl.appendChild(row);
      }).catch(logError);
      added++;
    }
  }
}


friendSearch.addEventListener('input', (e)=> doSearchAndRender(e.target.value, recommendations));
friendSearchDesktop.addEventListener('input', (e)=> doSearchAndRender(e.target.value, recommendationsDesktop));

// friends overlay toggle
friendsToggle.onclick = ()=> {
  if(window.innerWidth <= 760){
    friendsOverlay.classList.toggle('hidden');
    friendsOverlay.style.display = friendsOverlay.classList.contains('hidden') ? 'none' : 'block';
  } else friendsPanel.classList.toggle('hidden');
};
closeFriends.onclick = ()=> { friendsOverlay.classList.add('hidden'); friendsOverlay.style.display='none'; };

// open private chat
async function openPrivateWith(uid, username){
  try{
    const id = roomIdFor(currentUserUid, uid);
    // ensure participants exist
    const pRef = ref(db, `privateMessages/${id}/participants`);
    const pSnap = await get(pRef);
    if(!pSnap.exists()){
      await set(ref(db, `privateMessages/${id}/participants/${currentUserUid}`), true);
      await set(ref(db, `privateMessages/${id}/participants/${uid}`), true);
    } else {
      // ensure current is participant
      await set(ref(db, `privateMessages/${id}/participants/${currentUserUid}`), true);
    }
    currentRoomId = id;
    sendModeEl.textContent = `Modo: DM (${username})`;
    await listenPrivate(id);
    tabDM.classList.add('bg-gray-800'); tabGlobal.classList.remove('bg-gray-800');
  }catch(e){ logError(e); }
}

// send handler
sendBtn.addEventListener('click', async ()=>{
  const text = messageInput.value.trim();
  if(!text) return;
  try{
    const userSnap = await get(ref(db, `users/${currentUserUid}`));
    if(userSnap.exists() && userSnap.val().isBanned){ alert('VocÃª foi banido.'); return; }
    if(currentRoomId){
      await push(ref(db, `privateMessages/${currentRoomId}/messages`), { userId: currentUserUid, username: currentUsername, text, timestamp: Date.now() });
    } else {
      await push(ref(db, 'messages'), { userId: currentUserUid, username: currentUsername, text, timestamp: Date.now() });
    }
    messageInput.value = '';
  }catch(e){ logError(e); alert('Erro ao enviar'); }
});

// tabs
tabGlobal.addEventListener('click', async ()=>{
  currentRoomId = null;
  sendModeEl.textContent = 'Modo: Global';
  tabGlobal.classList.add('bg-gray-800'); tabDM.classList.remove('bg-gray-800');
  await loadAndListenGlobal();
});
tabDM.addEventListener('click', ()=>{ tabDM.classList.add('bg-gray-800'); tabGlobal.classList.remove('bg-gray-800'); messagesEl.innerHTML = '<div class="text-gray-400">Selecione um amigo para abrir DM.</div>'; });

// visibility change: refresh data when returning to tab
document.addEventListener('visibilitychange', ()=>{
  if(!document.hidden){
    // refresh messages and friends without full reload
    loadAndListenGlobal().catch(logError);
    loadFriendsUI().catch(logError);
    // refresh usernames cache already kept by onValue
  }
});

// logout: full signOut
logoutLink.addEventListener('click', async (e)=>{
  e.preventDefault();
  try{
    await fbSignOut(auth);
  }catch(e){ console.warn('signOut error', e); }
  localStorage.clear();
  sessionStorage.clear();
  // give a moment for signOut to propagate
  setTimeout(()=> location.href = 'index.html', 200);
});

// utility: accept friend request via console or later UI
async function acceptFriendRequest(fromUid){
  try{
    const fromSnap = await get(ref(db, `users/${fromUid}`));
    if(!fromSnap.exists()) return;
    const fromName = fromSnap.val().username || fromUid;
    await set(ref(db, `users/${currentUserUid}/friends/${fromUid}`), { username: fromName, addedAt: Date.now() });
    await set(ref(db, `users/${fromUid}/friends/${currentUserUid}`), { username: currentUsername, addedAt: Date.now() });
    await remove(ref(db, `friendRequests/${currentUserUid}/${fromUid}`));
    loadFriendsUI();
  }catch(e){ logError(e); }
}
window.acceptFriendRequest = acceptFriendRequest;

</script>
</body>
</html>
