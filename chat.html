<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chat â€” App (final)</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>

<style>
  :root{
    --bg:#0d1117; --panel:#0f1418; --muted:#c9d1d9;
    --mine:#5865F2; --other:#2f3136;
  }
  html,body{height:100%}
  body{background:var(--bg); color:var(--muted); font-family:Inter,system-ui; margin:0}
  .msg-bubble{display:inline-block; word-break:break-word; white-space:pre-wrap; border-radius:12px; padding:12px; box-shadow: 0 2px 6px rgba(0,0,0,.35)}
  .meta{font-size:12px; opacity:.78; margin-bottom:6px; display:flex; gap:10px; align-items:center}
  .meta .who{font-weight:600}
  .meta .time{font-size:11px; opacity:.6}
  .actions{display:flex; gap:8px; margin-top:8px; justify-content:flex-end}
  .small-btn{font-size:12px; padding:6px 10px; border-radius:8px}
  .fade{animation: fadeIn .18s ease-out}
  @keyframes fadeIn{from{opacity:0; transform:translateY(6px)}to{opacity:1; transform:none}}
  #friendsOverlay{display:none}
  @media (max-width:760px){
    #friendsPanel{display:none}
    #friendsToggle{display:inline-flex}
    #friendsOverlay{display:none; position:fixed; inset:0; background:rgba(0,0,0,.6); z-index:60; padding:12px; overflow:auto}
  }
  @media (min-width:761px){
    #friendsToggle{display:none}
    #friendsPanel{display:flex}
  }
  #messageInput{min-height:56px; max-height:180px; resize:none; width:100%}
  .msg-bubble{max-width:78%}
  .send-wrap{display:flex; flex-direction:column; gap:8px; align-items:flex-end}
  @media (max-width:420px){
    .msg-bubble{max-width:90%}
    #friendsPanel{display:none}
  }
  /* small stylings for friend requests area */
  .request-row{ padding:8px; border-radius:8px; background:#0b1115; display:flex; justify-content:space-between; align-items:center; margin-bottom:6px }
</style>
</head>
<body class="flex flex-col h-screen">

<header class="bg-[#0f1418] p-3 flex items-center justify-between border-b border-gray-800">
  <div class="flex items-center gap-3">
    <button id="friendsToggle" class="text-sm px-2 py-1 bg-gray-800 rounded hidden">Amigos</button>
    <strong class="text-sm">Chat AnÃ´nimo</strong>
    <div id="status" class="text-xs text-gray-400 ml-3">Conectando...</div>
  </div>

  <div class="flex items-center gap-3">
    <nav class="flex gap-2">
      <button id="tabGlobal" class="px-3 py-1 rounded bg-gray-800 text-sm">Global</button>
      <button id="tabDM" class="px-3 py-1 rounded text-sm">Mensagens</button>
    </nav>
    <a href="index.html" id="logoutLink" class="text-xs text-gray-400">Sair</a>
    <a href="admin.html" id="adminLink" class="text-xs text-red-400 hidden">Admin</a>
  </div>
</header>

<div class="flex-1 flex overflow-hidden">
  <main id="mainColumn" class="flex-1 flex flex-col">
    <div id="messages" class="flex-1 overflow-auto p-4 space-y-3 bg-[#161b22]"></div>

    <!-- typing indicator -->
    <div id="typingNotice" class="text-xs text-gray-400 px-6 py-1"></div>

    <section class="bg-[#0f1418] p-3 border-t border-gray-800 flex gap-3 items-start">
      <textarea id="messageInput" placeholder="Escreva..." class="flex-1 p-2 rounded bg-[#0f1418] border border-gray-700 text-sm" rows="2"></textarea>
      <div class="send-wrap">
        <button id="sendBtn" class="bg-blue-600 px-4 py-2 rounded text-sm">Enviar</button>
        <div id="sendMode" class="text-xs text-gray-400">Modo: Global</div>
      </div>
    </section>
  </main>

  <aside id="friendsPanel" class="w-80 bg-[#0f1418] border-l border-gray-800 p-3 hidden md:flex flex-col">
    <input id="friendSearchDesktop" placeholder="Pesquisar usuÃ¡rios..." class="w-full p-2 rounded bg-[#0f1418] border border-gray-700 text-sm mb-3" />
    <div id="recommendationsDesktop" class="space-y-2 mb-3"></div>

    <div>
      <h4 class="text-sm mb-2">SolicitaÃ§Ãµes</h4>
      <div id="friendRequestsListDesktop" class="mb-3"></div>
    </div>

    <div>
      <h4 class="text-sm mb-2">Seus amigos</h4>
      <div id="friendsAreaDesktop" class="space-y-2 max-h-[30vh] overflow:auto"></div>
    </div>

    <div class="mt-auto text-xs text-gray-400">NotificaÃ§Ãµes: <span id="notifCount">0</span></div>
  </aside>
</div>

<!-- friends overlay mobile -->
<div id="friendsOverlay" class="hidden">
  <div class="bg-[#0f1418] rounded p-3 h-full">
    <div class="flex gap-2 mb-3">
      <input id="friendSearch" placeholder="Pesquisar usuÃ¡rios..." class="flex-1 p-2 rounded bg-[#0f1418] border border-gray-700 text-sm" />
      <button id="closeFriends" class="px-3 py-2 bg-gray-700 rounded">Fechar</button>
    </div>
    <div id="recommendations" class="space-y-2"></div>

    <div class="mt-4">
      <h4 class="text-sm mb-2">SolicitaÃ§Ãµes</h4>
      <div id="friendRequestsList" class="mb-3"></div>
    </div>

    <div class="mt-4">
      <h4 class="text-sm mb-2">Seus amigos</h4>
      <div id="friendsArea" class="space-y-2"></div>
    </div>
  </div>
</div>

<script type="module">
/* chat.html final: Global + DM + friend requests + typing + admin force/logout + blocked write check
   Use the Realtime DB rules we agreed on (typing, privateMessages, users, friendRequests, admins).
*/

import { initializeApp } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-app.js";
import { getAuth, signInAnonymously, onAuthStateChanged, signOut as fbSignOut } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-auth.js";
import {
  getDatabase, ref, push, onChildAdded, onChildChanged, onChildRemoved,
  get, set, update, onValue, remove, off
} from "https://www.gstatic.com/firebasejs/12.5.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyDAQS7qpWTDH7itAgn1eAJIeLOfVxy__cM",
  authDomain: "chat-firebase-efcbe.firebaseapp.com",
  databaseURL: "https://chat-firebase-efcbe-default-rtdb.firebaseio.com",
  projectId: "chat-firebase-efcbe",
  storageBucket: "chat-firebase-efcbe.firebasestorage.app",
  messagingSenderId: "376919463932",
  appId: "1:376919463932:web:4b2139df551d0a026ac479",
  measurementId: "G-R14XVTJBFL"
};
const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const auth = getAuth(app);

// UI refs
const statusEl = document.getElementById('status');
const messagesEl = document.getElementById('messages');
const messageInput = document.getElementById('messageInput');
const sendBtn = document.getElementById('sendBtn');
const sendModeEl = document.getElementById('sendMode');
const typingNotice = document.getElementById('typingNotice');

const friendsToggle = document.getElementById('friendsToggle');
const friendsOverlay = document.getElementById('friendsOverlay');
const friendsPanel = document.getElementById('friendsPanel');
const friendSearch = document.getElementById('friendSearch');
const friendSearchDesktop = document.getElementById('friendSearchDesktop');
const recommendations = document.getElementById('recommendations');
const recommendationsDesktop = document.getElementById('recommendationsDesktop');
const friendsArea = document.getElementById('friendsArea');
const friendsAreaDesktop = document.getElementById('friendsAreaDesktop');
const friendRequestsList = document.getElementById('friendRequestsList');
const friendRequestsListDesktop = document.getElementById('friendRequestsListDesktop');
const closeFriends = document.getElementById('closeFriends');

const tabGlobal = document.getElementById('tabGlobal');
const tabDM = document.getElementById('tabDM');
const adminLink = document.getElementById('adminLink');
const notifCountEl = document.getElementById('notifCount');
const logoutLink = document.getElementById('logoutLink');

let currentUserUid = localStorage.getItem('chat_user_uid') || null;
let currentUsername = localStorage.getItem('chat_user_username') || 'AnÃ´nimo';
let authUid = null;
let currentRoomId = null; // null = global
let markedParse = window.marked;

// usernames cache
let allUsernames = {};
onValue(ref(db, 'usernames'), snap=>{
  allUsernames = snap.exists() ? snap.val() : {};
  // refresh recommendations if user is typing in search
  const active = document.activeElement;
  if(active === friendSearch || active === friendSearchDesktop){
    const value = active.value;
    if(active === friendSearch) doSearchAndRender(value, recommendations);
    else doSearchAndRender(value, recommendationsDesktop);
  }
});

// helpers
function renderMarkdown(md){ const html = markedParse.parse(md||''); return DOMPurify.sanitize(html); }
function timeStr(ts){ try{ return new Date(ts).toLocaleTimeString(); }catch(e){ return ''; } }
function logError(e){ console.error('CHAT ERROR', e); }

// message element
function createMessageElement(id, data, isPrivate=false){
  const wrapper = document.createElement('div');
  wrapper.className = 'fade flex';
  wrapper.style.justifyContent = (data.userId === currentUserUid) ? 'flex-end' : 'flex-start';
  wrapper.dataset.msgId = id;

  const bubble = document.createElement('div');
  bubble.className = 'msg-bubble';
  bubble.style.background = (data.userId === currentUserUid) ? 'var(--mine)' : 'var(--other)';
  bubble.style.color = (data.userId === currentUserUid) ? 'white' : '#d6dbe3';
  bubble.style.maxWidth = '78%';

  const meta = document.createElement('div'); meta.className = 'meta';
  const who = document.createElement('div'); who.className = 'who'; who.textContent = data.username || 'AnÃ´nimo';
  const t = document.createElement('div'); t.className = 'time'; t.textContent = (data.timestamp ? `â€¢ ${timeStr(data.timestamp)}` : '');
  meta.appendChild(who); meta.appendChild(t);

  const content = document.createElement('div'); content.className = 'content'; content.innerHTML = renderMarkdown(data.text || '');

  bubble.appendChild(meta); bubble.appendChild(content);

  if(data.userId === currentUserUid){
    const actions = document.createElement('div'); actions.className = 'actions';
    const editBtn = document.createElement('button'); editBtn.className = 'small-btn text-xs text-gray-200'; editBtn.textContent = 'editar';
    const delBtn = document.createElement('button'); delBtn.className = 'small-btn text-xs text-red-400'; delBtn.textContent = 'apagar';

    editBtn.onclick = ()=> openModal('Editar mensagem', data.text, async (newText)=>{
      if(!newText.trim()) return;
      const path = isPrivate ? `privateMessages/${currentRoomId}/messages/${id}` : `messages/${id}`;
      try{ await update(ref(db, path), { text:newText, editedAt: Date.now() }); }catch(e){ logError(e); }
    });

    delBtn.onclick = ()=> openModal('Apagar mensagem', 'Tem certeza?', async ()=>{
      const path = isPrivate ? `privateMessages/${currentRoomId}/messages/${id}` : `messages/${id}`;
      try{ await remove(ref(db, path)); }catch(e){ logError(e); }
    }, true);

    actions.appendChild(editBtn); actions.appendChild(delBtn);
    bubble.appendChild(actions);
  }

  wrapper.appendChild(bubble);
  return wrapper;
}

// modal helper
function openModal(title, content, onConfirm, confirmOnly=false){
  const modal = document.createElement('div');
  Object.assign(modal.style,{position:'fixed', inset:0, background:'rgba(0,0,0,0.6)', display:'flex', alignItems:'center', justifyContent:'center', zIndex:120});
  const box = document.createElement('div'); Object.assign(box.style,{background:'#111318', padding:'14px', borderRadius:'8px', width:'92%', maxWidth:'420px'});
  const h = document.createElement('h3'); h.textContent = title; h.className='text-sm mb-2'; box.appendChild(h);
  let inputEl = null;
  if(!confirmOnly){
    inputEl = document.createElement('textarea'); inputEl.className = 'w-full p-2 rounded bg-[#0f1418] border border-gray-700 mb-3'; inputEl.value = content || '';
    box.appendChild(inputEl);
  } else {
    const p = document.createElement('p'); p.className='text-xs mb-3'; p.textContent = content; box.appendChild(p);
  }
  const row = document.createElement('div'); row.className='flex justify-end gap-2';
  const bCancel = document.createElement('button'); bCancel.className='px-3 py-1 bg-gray-700 rounded'; bCancel.textContent='Cancelar'; bCancel.onclick = ()=> modal.remove();
  const bOk = document.createElement('button'); bOk.className='px-3 py-1 bg-blue-600 rounded'; bOk.textContent='Confirmar';
  bOk.onclick = async ()=>{ await onConfirm(inputEl ? inputEl.value : ''); modal.remove(); };
  row.appendChild(bCancel); row.appendChild(bOk); box.appendChild(row); modal.appendChild(box); document.body.appendChild(modal);
}

// typing
let typingTimeout = null;
function setTyping(isTyping){
  const room = currentRoomId || 'global';
  const tRef = ref(db, `typing/${room}/${currentUserUid}`);
  if(isTyping){
    set(tRef, { uid: currentUserUid, username: currentUsername, at: Date.now() }).catch(()=>{});
    if(typingTimeout) clearTimeout(typingTimeout);
    typingTimeout = setTimeout(()=> { remove(tRef).catch(()=>{}); }, 4000);
  } else {
    remove(tRef).catch(()=>{});
    if(typingTimeout) clearTimeout(typingTimeout);
  }
}

messageInput.addEventListener('input', ()=> {
  setTyping(true);
});

// hide typing on blur/unload
window.addEventListener('blur', ()=> setTyping(false));
window.addEventListener('beforeunload', ()=> setTyping(false));

// watch typing in a room (keeps single listener)
let typingWatchRef = null;
function watchTypingForRoom(roomId){
  // detach previous
  if(typingWatchRef) off(typingWatchRef);
  const rr = ref(db, `typing/${roomId}`);
  typingWatchRef = rr;
  onValue(rr, snap=>{
    const obj = snap.val() || {};
    const others = Object.values(obj).filter(o => o.uid !== currentUserUid);
    if(others.length === 0){ typingNotice.textContent = ''; return; }
    const names = others.slice(0,3).map(o => o.username || o.uid);
    typingNotice.textContent = names.join(', ') + (others.length > 1 ? ' estÃ£o digitando...' : ' estÃ¡ digitando...');
  });
}

// listeners management for private rooms
let currentPrivateRef = null;
function detachPrivateListeners(){
  if(currentPrivateRef) {
    try{ off(currentPrivateRef); }catch(e){}
    currentPrivateRef = null;
  }
}

// global listeners (attach once)
let globalListenerAttached = false;
let displayedGlobal = new Set();

async function loadAndListenGlobal(){
  try{
    const refGlobal = ref(db, 'messages');
    // initial
    const snap = await get(refGlobal);
    messagesEl.innerHTML = '';
    displayedGlobal.clear();
    if(snap.exists()){
      const data = snap.val();
      const keys = Object.keys(data).sort((a,b)=> (data[a].timestamp||0) - (data[b].timestamp||0));
      for(const k of keys){ displayedGlobal.add(k); messagesEl.appendChild(createMessageElement(k, data[k], false)); }
      messagesEl.scrollTop = messagesEl.scrollHeight;
    } else messagesEl.innerHTML = '<div class="text-gray-400">Sem mensagens pÃºblicas.</div>';

    if(!globalListenerAttached){
      onChildAdded(refGlobal, s=>{
        const id = s.key;
        if(displayedGlobal.has(id)) return;
        displayedGlobal.add(id);
        messagesEl.appendChild(createMessageElement(id, s.val(), false));
        messagesEl.scrollTop = messagesEl.scrollHeight;
      });
      onChildChanged(refGlobal, s=>{
        const id = s.key;
        const n = messagesEl.querySelector(`[data-msg-id="${id}"]`);
        if(n) n.replaceWith(createMessageElement(id, s.val(), false));
      });
      onChildRemoved(refGlobal, s=>{
        const id = s.key;
        const n = messagesEl.querySelector(`[data-msg-id="${id}"]`);
        if(n) n.remove();
        displayedGlobal.delete(id);
      });
      globalListenerAttached = true;
    }
    // watch typing on global
    watchTypingForRoom('global');
  }catch(e){ logError(e); }
}

// private room listener
async function listenPrivate(roomId){
  try{
    // detach previous
    detachPrivateListeners();
    currentPrivateRef = ref(db, `privateMessages/${roomId}/messages`);
    // initial
    const snap = await get(currentPrivateRef);
    messagesEl.innerHTML = '';
    if(snap.exists()){
      const data = snap.val();
      const keys = Object.keys(data).sort((a,b)=> (data[a].timestamp||0) - (data[b].timestamp||0));
      for(const k of keys) messagesEl.appendChild(createMessageElement(k, data[k], true));
      messagesEl.scrollTop = messagesEl.scrollHeight;
    } else messagesEl.innerHTML = '<div class="text-gray-400">Sem mensagens nessa conversa.</div>';
    // attach listeners
    onChildAdded(currentPrivateRef, s=>{
      if(messagesEl.querySelector(`[data-msg-id="${s.key}"]`)) return;
      messagesEl.appendChild(createMessageElement(s.key, s.val(), true));
      messagesEl.scrollTop = messagesEl.scrollHeight;
    });
    onChildChanged(currentPrivateRef, s=>{
      const n = messagesEl.querySelector(`[data-msg-id="${s.key}"]`);
      if(n) n.replaceWith(createMessageElement(s.key, s.val(), true));
    });
    onChildRemoved(currentPrivateRef, s=>{
      const n = messagesEl.querySelector(`[data-msg-id="${s.key}"]`);
      if(n) n.remove();
    });
    // watch typing for this room
    watchTypingForRoom(roomId);
  }catch(e){ logError(e); }
}

// deterministic room ID
function roomIdFor(a,b){ return [a,b].sort().join('_'); }

// ensure auth
async function ensureAuth(){
  return new Promise((resolve)=>{
    if(auth.currentUser){ resolve(auth.currentUser); return; }
    const unsub = onAuthStateChanged(auth, (user)=>{
      if(user){ unsub(); resolve(user); }
    });
    signInAnonymously(auth).catch((e)=> console.warn('signInAnonymously failed', e));
  });
}

// force logout listener (admin action)
let forceLogoutUnsub = null;
function watchForceLogout(){
  const fRef = ref(db, `users/${currentUserUid}/forceLogoutAt`);
  if(forceLogoutUnsub) off(forceLogoutUnsub);
  forceLogoutUnsub = fRef;
  onValue(fRef, async snap=>{
    if(!snap.exists()) return;
    const ts = snap.val();
    // force signout
    alert('VocÃª foi deslogado pelo administrador.');
    try{ await fbSignOut(auth); }catch(e){}
    localStorage.clear();
    location.href = 'index.html';
  });
}

// friends UI loaders
async function loadFriendsUI(){
  try{
    const s = await get(ref(db, `users/${currentUserUid}/friends`));
    friendsArea.innerHTML = ''; friendsAreaDesktop.innerHTML = '';
    if(!s.exists()) return;
    const f = s.val();
    for(const uid of Object.keys(f)){
      const name = f[uid].username || uid;
      const btn = document.createElement('button'); btn.className = 'w-full text-left px-3 py-2 bg-gray-800 rounded'; btn.textContent = name;
      btn.onclick = ()=> openPrivateWith(uid, name);
      friendsArea.appendChild(btn);
      const clone = btn.cloneNode(true); clone.onclick = btn.onclick; friendsAreaDesktop.appendChild(clone);
    }
  }catch(e){ logError(e); }
}
onValue(ref(db, `users/${currentUserUid}/friends`), ()=> loadFriendsUI());

//friend requests rendering and listeners//
function renderFriendRequests(snap, outEl){
  outEl.innerHTML = '';
  if(!snap.exists()) return;
  const reqs = snap.val();
  for(const fromUid in reqs){
    const r = reqs[fromUid];
    const row = document.createElement('div');
    row.className = 'request-row';
    const name = document.createElement('div'); name.textContent = r.username || fromUid;
    const actions = document.createElement('div');
    const accept = document.createElement('button'); accept.textContent='Aceitar'; accept.className='small-btn bg-blue-600 text-white mr-2';
    const decline = document.createElement('button'); decline.textContent='Recusar'; decline.className='small-btn bg-gray-700 text-white';
    accept.onclick = async ()=>{
      try{
        const fromSnap = await get(ref(db, `users/${fromUid}`));
        const fromName = fromSnap.exists() ? fromSnap.val().username : 'Amigo';
        await set(ref(db, `users/${currentUserUid}/friends/${fromUid}`), { username: fromName, addedAt: Date.now() });
        await set(ref(db, `users/${fromUid}/friends/${currentUserUid}`), { username: currentUsername, addedAt: Date.now() });
        const id = roomIdFor(currentUserUid, fromUid);
        await set(ref(db, `privateMessages/${id}/participants/${currentUserUid}`), true);
        await set(ref(db, `privateMessages/${id}/participants/${fromUid}`), true);
        await remove(ref(db, `friendRequests/${currentUserUid}/${fromUid}`));
      }catch(e){ logError(e); }
    };
    decline.onclick = async ()=> { try{ await remove(ref(db, `friendRequests/${currentUserUid}/${fromUid}`)); }catch(e){ logError(e); } };
    actions.appendChild(accept); actions.appendChild(decline);
    row.appendChild(name); row.appendChild(actions);
    outEl.appendChild(row);
  }
}

onValue(ref(db, `friendRequests/${currentUserUid}`), snap=>{
  renderFriendRequests(snap, friendRequestsList);
  renderFriendRequests(snap, friendRequestsListDesktop);
  const count = snap.exists() ? Object.keys(snap.val()).length : 0;
  notifCountEl.textContent = count;
});

// search recommendations (debounced-ish simplified)
function doSearchAndRender(q, outEl){
  outEl.innerHTML = '';
  if(!q) return;
  const low = q.toLowerCase();
  let added = 0;
  for(const unameKey of Object.keys(allUsernames)){
    if(added >= 12) break;
    if(unameKey.includes(low)){
      const uid = allUsernames[unameKey];
      if(uid === currentUserUid) continue;
      get(ref(db, `users/${uid}`)).then(s=>{
        if(!s.exists()) return;
        const user = s.val();
        const row = document.createElement('div'); row.className='p-2 bg-[#111318] rounded flex justify-between items-center';
        const name = document.createElement('div'); name.textContent = user.username;
        name.style.cursor = 'pointer';
        name.onclick = ()=>{
          if(outEl === recommendations) friendSearch.value = user.username;
          if(outEl === recommendationsDesktop) friendSearchDesktop.value = user.username;
        };
        const addBtn = document.createElement('button'); addBtn.textContent = 'Adicionar'; addBtn.className = 'small-btn bg-blue-600 text-white';
        addBtn.onclick = async ()=>{
          try{
            await set(ref(db, `friendRequests/${uid}/${currentUserUid}`), { username: currentUsername, from: currentUserUid, at: Date.now() });
            addBtn.textContent = 'Enviado';
          }catch(e){ logError(e); addBtn.textContent = 'Erro'; }
        };
        row.appendChild(name); row.appendChild(addBtn); outEl.appendChild(row);
      }).catch(logError);
      added++;
    }
  }
}

friendSearch.addEventListener('input', e => doSearchAndRender(e.target.value, recommendations));
friendSearchDesktop.addEventListener('input', e => doSearchAndRender(e.target.value, recommendationsDesktop));

// open private chat
async function openPrivateWith(uid, username){
  try{
    const id = roomIdFor(currentUserUid, uid);
    // ensure participants exist
    const pRef = ref(db, `privateMessages/${id}/participants`);
    const pSnap = await get(pRef);
    if(!pSnap.exists()){
      await set(ref(db, `privateMessages/${id}/participants/${currentUserUid}`), true);
      await set(ref(db, `privateMessages/${id}/participants/${uid}`), true);
    } else {
      await set(ref(db, `privateMessages/${id}/participants/${currentUserUid}`), true);
    }
    currentRoomId = id;
    sendModeEl.textContent = `Modo: DM (${username})`;
    await listenPrivate(id);
    tabDM.classList.add('bg-gray-800'); tabGlobal.classList.remove('bg-gray-800');
  }catch(e){ logError(e); }
}

// send message (check blocked/ban and write to correct path)
sendBtn.addEventListener('click', async ()=>{
  const text = messageInput.value.trim();
  if(!text) return;
  try{
    // block/banned check
    const userSnap = await get(ref(db, `users/${currentUserUid}`));
    if(userSnap.exists()){
      const u = userSnap.val();
      if(u.isBanned){ alert('VocÃª foi banido.'); return; }
      if(u.isBlocked){ alert('VocÃª foi silenciado pelo administrador.'); return; }
    }

    if(currentRoomId){
      await push(ref(db, `privateMessages/${currentRoomId}/messages`), { userId: currentUserUid, username: currentUsername, text, timestamp: Date.now() });
    } else {
      await push(ref(db, 'messages'), { userId: currentUserUid, username: currentUsername, text, timestamp: Date.now() });
    }
    messageInput.value = '';
    setTyping(false);
  }catch(e){ logError(e); alert('Erro ao enviar'); }
});

// tabs behavior
tabGlobal.addEventListener('click', async ()=>{
  currentRoomId = null;
  sendModeEl.textContent = 'Modo: Global';
  tabGlobal.classList.add('bg-gray-800'); tabDM.classList.remove('bg-gray-800');
  detachPrivateListeners();
  await loadAndListenGlobal();
});
tabDM.addEventListener('click', ()=>{ tabDM.classList.add('bg-gray-800'); tabGlobal.classList.remove('bg-gray-800'); messagesEl.innerHTML = '<div class="text-gray-400">Selecione um amigo para abrir DM.</div>'; });

// visibility handling: refresh lightweight things when tab becomes visible
document.addEventListener('visibilitychange', ()=>{
  if(!document.hidden){
    // refresh global messages and friends list if in global
    if(!currentRoomId) loadAndListenGlobal().catch(logError);
    loadFriendsUI().catch(logError);
  }
});

// logout (full sign out)
logoutLink.addEventListener('click', async (e)=>{
  e.preventDefault();
  try{ await fbSignOut(auth); }catch(e){ console.warn('signOut error', e); }
  localStorage.clear(); sessionStorage.clear();
  setTimeout(()=> location.href = 'index.html', 150);
});

// watch admin status to show admin link
(async function displayAdminIf(){
  try{
    const adm = await get(ref(db, `admins/${currentUserUid}`));
    if(adm.exists() && adm.val() === true) adminLink.classList.remove('hidden');
  }catch(e){ }
})();

// auth bootstrap
async function bootstrap(){
  try{
    await ensureAuth();
    // if local storage uid missing, fall back to auth uid (makes testing easier)
    if(!currentUserUid && auth.currentUser){
      currentUserUid = auth.currentUser.uid;
      localStorage.setItem('chat_user_uid', currentUserUid);
      localStorage.setItem('chat_user_username', currentUsername);
    }
    statusEl.textContent = 'Carregando...';

    // start global messages
    await loadAndListenGlobal();

    // presence tracking
    onValue(ref(db, '.info/connected'), snap=>{
      if(snap.val() === true){
        try{ set(ref(db, `status/${currentUserUid}`), { state:'online', last_changed: Date.now() }); }catch(e){}
        statusEl.innerHTML = '<span class="text-green-500">ðŸŸ¢ Online</span>';
        window.addEventListener('beforeunload', ()=> {
          try{ set(ref(db, `status/${currentUserUid}`), { state:'offline', last_changed: Date.now() }); }catch(e){}
        });
      } else statusEl.innerHTML = '<span class="text-red-500">ðŸ”´ Offline</span>';
    });

    // watch force logout flag
    watchForceLogout();

    // initial friends UI
    await loadFriendsUI();

    statusEl.textContent = 'Pronto';
  }catch(e){ logError(e); statusEl.textContent = 'Erro'; }
}
bootstrap();

// watch for changes to user's blocked/forceLogout etc (reactive)
onValue(ref(db, `users/${currentUserUid}`), snap=>{
  if(!snap.exists()) return;
  const val = snap.val();
  // if admin set isBlocked while user is in page, show notice (and disabled sending is enforced on send)
  if(val.isBlocked) {
    // optional: show a subtle message
    // console.log('VocÃª estÃ¡ silenciado pelo admin.');
  }
});

// watch friend requests handled above via onValue

// utility: accept friend request exposed for console if needed
window.acceptFriendRequest = async (fromUid) => {
  try{
    const fromSnap = await get(ref(db, `users/${fromUid}`));
    const fromName = fromSnap.exists() ? fromSnap.val().username : 'Amigo';
    await set(ref(db, `users/${currentUserUid}/friends/${fromUid}`), { username: fromName, addedAt: Date.now() });
    await set(ref(db, `users/${fromUid}/friends/${currentUserUid}`), { username: currentUsername, addedAt: Date.now() });
    const id = roomIdFor(currentUserUid, fromUid);
    await set(ref(db, `privateMessages/${id}/participants/${currentUserUid}`), true);
    await set(ref(db, `privateMessages/${id}/participants/${fromUid}`), true);
    await remove(ref(db, `friendRequests/${currentUserUid}/${fromUid}`));
    loadFriendsUI();
  }catch(e){ logError(e); }
};

</script>
</body>
</html>
