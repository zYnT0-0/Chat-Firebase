<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chat — App (final)</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>

<style>
  :root{
    --bg:#0d1117; --panel:#0f1418; --muted:#c9d1d9;
    --mine:#5865F2; --other:#2f3136;
  }
  html,body{height:100%}
  body{background:var(--bg); color:var(--muted); font-family:Inter,system-ui; margin:0}
  .msg-bubble{display:inline-block; word-break:break-word; white-space:pre-wrap; border-radius:12px; padding:12px; box-shadow: 0 2px 6px rgba(0,0,0,.35)}
  .meta{font-size:12px; opacity:.78; margin-bottom:6px; display:flex; gap:10px; align-items:center}
  .meta .who{font-weight:600}
  .meta .time{font-size:11px;}

  /* NOVO CÓDIGO - ALERTA TOAST */
  .alert-toast {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: var(--panel); 
    color: var(--muted);
    padding: 12px 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    z-index: 1000;
    transition: opacity 0.3s, transform 0.3s;
    opacity: 0;
    transform: translateY(20px);
  }
  .alert-toast.show {
    opacity: 1;
    transform: translateY(0);
  }
  .alert-toast.danger {
    background: #ef4444; /* Vermelho */
    color: white;
  }
</style>
</head>
<body class="flex flex-col h-screen">

<div id="header" class="p-4 bg-gray-900 border-b border-gray-700/50 flex justify-between items-center">
  <div class="text-xl font-bold">Chat Global</div>
  <nav class="flex gap-4 text-sm">
    <a id="adminLink" href="admin.html" class="hover:text-blue-400 hidden">Admin</a>
    <a href="profile.html" class="hover:text-blue-400">Meu Perfil</a> 
    <a id="logout" href="#" class="hover:text-red-400">Sair</a>
  </nav>
</div>

<div id="messages" class="flex-1 overflow-y-auto p-4 space-y-4">
  </div>

<div id="statusEl" class="text-xs italic text-gray-500 p-1 text-right">Carregando...</div>

<div id="typingStatus" class="text-xs italic text-gray-500 mb-1 h-4 ml-4"></div>

<div id="chatFooter" class="p-4 bg-gray-800 flex items-center">
  <input id="messageInput" type="text" placeholder="Escreva uma mensagem..." class="flex-1 p-3 rounded-l-lg bg-gray-700 text-white border border-gray-600 focus:outline-none focus:border-blue-500" />
  <button id="sendBtn" class="bg-blue-600 hover:bg-blue-700 text-white p-3 rounded-r-lg font-semibold transition-colors">Enviar</button>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-app.js";
import { getDatabase, ref, set, push, onValue, update, get, serverTimestamp } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-database.js";
import { getAuth, signInAnonymously, signOut } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-auth.js";

// Configuração do Firebase (assumindo que a sua está aqui)
const firebaseConfig = {
  "apiKey": "AIzaSyDAQS7qpWTDH7itAgn1eAJIeLOfVxy__cM",
  "authDomain": "chat-firebase-efcbe.firebaseapp.com",
  "databaseURL": "https://chat-firebase-efcbe-default-rtdb.firebaseio.com",
  "projectId": "chat-firebase-efcbe",
  "storageBucket": "chat-firebase-efcbe.firebasestorage.app",
  "messagingSenderId": "376919463932",
  "appId": "1:376919463932:web:4b2100d024467d169d2d09"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const auth = getAuth(app);

const currentUserUid = localStorage.getItem('chat_user_uid');
const currentUsername = localStorage.getItem('chat_user_username');
const isAdmin = JSON.parse(localStorage.getItem('chat_is_admin') || 'false');

if (!currentUserUid || !currentUsername) {
  location.href = 'index.html';
}

const messageInput = document.getElementById('messageInput');
const sendBtn = document.getElementById('sendBtn');
const messagesEl = document.getElementById('messages');
const statusEl = document.getElementById('statusEl');
const adminLink = document.getElementById('adminLink');

let isBlocked = false;
let currentTimeout;
const TYPING_TIMEOUT = 3000;

// =========================================================================
// FUNÇÕES UTILITY
// =========================================================================

// NOVA FUNÇÃO: Alerta estilizado e seguro
function showAlert(message, type = 'default') {
    // PREVENÇÃO DE VAZAMENTO DE DADOS: Remove URLs e UIDs de mensagens de erro
    let safeMessage = String(message).replace(/https?:\/\/[^\s]+/g, 'https://www.spanishdict.com/translate/removido').replace(/[a-zA-Z0-9]{28}/g, '[UID Removido]');
    
    const alertEl = document.createElement('div');
    alertEl.className = `alert-toast ${type}`;
    alertEl.textContent = safeMessage;
    
    document.body.appendChild(alertEl);
    
    setTimeout(() => { alertEl.classList.add('show'); }, 10);
    setTimeout(() => {
        alertEl.classList.remove('show');
        setTimeout(() => alertEl.remove(), 300);
    }, 5000); 
}

// NOVO CÓDIGO: Substitui logError
window.logError = (e) => { 
  console.error(e); 
  showAlert(e.message || 'Um erro desconhecido ocorreu.', 'danger'); 
}

const el = (tag, classes) => {
  const element = document.createElement(tag);
  if(classes) element.className = classes;
  return element;
};

const scrollToBottom = () => {
  messagesEl.scrollTop = messagesEl.scrollHeight;
};

// =========================================================================
// PRESENÇA E DIGITAÇÃO
// =========================================================================

// Define o status de presença (online)
const setPresence = (isOnline) => {
  const statusRef = ref(db, `status/${currentUserUid}`);
  if (isOnline) {
    update(statusRef, { isOnline: true, lastSeen: Date.now(), username: currentUsername });
    // Configura onDisconnect
    onValue(ref(db, '.info/connected'), (snap) => {
      if (snap.val() === true) {
        statusRef.onDisconnect().update({ isOnline: false, lastSeen: Date.now() });
      }
    });
  } else {
    update(statusRef, { isOnline: false, lastSeen: Date.now() });
  }
};

// Define o status de digitação
const setTyping = (isTyping) => {
  const typingRef = ref(db, `typing/global/${currentUserUid}`);
  if (isTyping) {
    set(typingRef, { username: currentUsername, at: Date.now() });
  } else {
    set(typingRef, null);
  }
};

// Listener para o input
messageInput.addEventListener('input', () => {
  if (isBlocked) return;
  setTyping(true);

  clearTimeout(currentTimeout);
  currentTimeout = setTimeout(() => {
    setTyping(false);
  }, TYPING_TIMEOUT);
});

// =========================================================================
// CHAT PRINCIPAL
// =========================================================================

// envia mensagem
const sendMessage = async () => {
  const text = messageInput.value.trim();
  if (!text || isBlocked) {
    if(isBlocked) showAlert('Você está silenciado e não pode enviar mensagens.', 'danger');
    return;
  }

  try {
    const newMessageRef = push(ref(db, 'messages'));
    await set(newMessageRef, {
      userId: currentUserUid,
      username: currentUsername,
      text: text,
      timestamp: serverTimestamp()
    });
    messageInput.value = '';
    setTyping(false); 
    clearTimeout(currentTimeout); // Garante que o flag de digitação seja limpo
  } catch (err) {
    logError(err);
  }
};

sendBtn.addEventListener('click', sendMessage);
messageInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    sendMessage();
  }
});

// Função para renderizar mensagens
let lastMsgTimestamp = 0;
const renderMessage = (msgId, data) => {
  const isMine = data.userId === currentUserUid;
  const username = data.username || 'Usuário Desconhecido';
  const timestamp = data.timestamp;

  const msgTime = new Date(timestamp);
  const timeString = msgTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

  // Cria a bolha da mensagem
  const msgWrapper = el('div', 'flex ' + (isMine ? 'justify-end' : 'justify-start'));
  const msgContent = el('div', 'flex flex-col max-w-lg');
  const bubble = el('div', 'msg-bubble ' + (isMine ? 'bg-mine text-white' : 'bg-other text-white/90'));
  bubble.innerHTML = DOMPurify.sanitize(marked.parse(data.text));

  // Cria o meta
  const meta = el('div', 'meta ' + (isMine ? 'justify-end' : 'justify-start'));
  const who = el('span', 'who ' + (isMine ? 'text-white/80' : 'text-white/80'));
  who.textContent = username;

  const time = el('span', 'time');
  time.textContent = timeString;

  meta.appendChild(who);
  meta.appendChild(time);
  
  // Adiciona evento ao username (abre perfil)
  who.onclick = () => {
      // SEGURANÇA: Não passa UID na URL
      if (isMine) {
          location.href = 'profile.html';
      } else {
          // Se for outro usuário, pode passar o UID se o profile.html for seguro
          // ALTERNATIVA: location.href = `profile.html?uid=${data.userId}`;
          // Para manter a segurança, mantenha apenas o nome.
          // Se o perfil precisar de UID, você terá que reavaliar a política de segurança.
          showAlert(`Abrindo perfil de ${username}...`, 'default');
          location.href = `profile.html?uid=${data.userId}`;
      }
  };

  msgContent.appendChild(meta);
  msgContent.appendChild(bubble);
  msgWrapper.appendChild(msgContent);
  messagesEl.appendChild(msgWrapper);
};

// Listener para novas mensagens
onValue(ref(db, 'messages'), (snapshot) => {
  messagesEl.innerHTML = ''; // Limpa tudo para renderizar o histórico
  snapshot.forEach((childSnapshot) => {
    const data = childSnapshot.val();
    // Verifica se a mensagem tem conteúdo válido
    if(data && data.text) {
        renderMessage(childSnapshot.key, data);
    }
  });
  scrollToBottom();
});

// =========================================================================
// SETUP E CHECAGENS
// =========================================================================

const checkAdmin = async () => {
  const adminSnap = await get(ref(db, `admins/${currentUserUid}`));
  if (adminSnap.exists() && adminSnap.val() === true) {
    adminLink.classList.remove('hidden');
    localStorage.setItem('chat_is_admin', 'true');
  } else {
    localStorage.setItem('chat_is_admin', 'false');
  }
};

const checkForceLogout = async (val) => {
  // 1. Checa Banimento na inicialização
  if(val.isBanned) {
    showAlert('Você está banido permanentemente.', 'danger');
    await signOut(auth);
    localStorage.clear();
    location.href = 'index.html';
    return true;
  }
  // 2. Checa Bloqueio na inicialização
  isBlocked = val.isBlocked;
  if (isBlocked) {
    showAlert('Você está silenciado e não pode enviar mensagens.', 'danger');
  }

  return false;
}

// watch for changes to user's blocked/forceLogout etc (reactive)
onValue(ref(db, `users/${currentUserUid}`), snap=>{
  if(!snap.exists()) return;
  const val = snap.val();
  
  // VERIFICAÇÃO DE DESLOGAMENTO FORÇADO (KICK)
  // O valor de forceLogoutAt é comparado com o tempo atual - 5 segundos para garantir que o evento não seja antigo
  if(val.forceLogoutAt && val.forceLogoutAt > Date.now() - 5000) {
    showAlert('Você foi desconectado pelo Administrador.', 'danger');
    
    setTimeout(async () => {
      try{ await signOut(auth); localStorage.clear(); location.href = 'index.html'; }catch(e){ console.warn(e); }
    }, 1000); 
    return; 
  }

  // se admin set isBlocked while user is in page, show notice
  if(val.isBlocked !== isBlocked) {
    isBlocked = val.isBlocked;
    if (isBlocked) {
        showAlert('Sua conta foi silenciada pelo Administrador.', 'danger');
    } else {
        showAlert('Seu silêncio foi removido pelo Administrador.', 'default');
    }
  } else if (val.isBanned) {
    showAlert('Sua conta foi banida permanentemente pelo Administrador.', 'danger');
  }
});


// watch typing flags (to show if any user typing in rooms)
onValue(ref(db,'typing'), snap=> {
  const typingStatusEl = document.getElementById('typingStatus');
  if(!typingStatusEl) return;
  
  const typingUsers = [];
  const rooms = snap.val() || {};

  // Verifica o chat global (assumindo a chave 'global')
  const globalTyping = rooms['global'] || {}; 

  for(const uid in globalTyping){
    // Exclui o próprio usuário
    if(uid !== currentUserUid && globalTyping[uid] && globalTyping[uid].username){
      typingUsers.push(globalTyping[uid].username);
    }
  }

  if(typingUsers.length === 1){
    typingStatusEl.textContent = `${typingUsers[0]} está digitando...`;
  } else if(typingUsers.length > 1){
    // Exibe os 2 primeiros + "e mais" se houver mais de 2
    const othersCount = typingUsers.length - 2;
    if (othersCount > 0) {
        typingStatusEl.textContent = `${typingUsers.slice(0, 2).join(', ')} e mais ${othersCount} estão digitando...`;
    } else {
        typingStatusEl.textContent = `${typingUsers.join(' e ')} estão digitando...`;
    }
  } else {
    typingStatusEl.textContent = ''; // Limpa quando ninguém estiver digitando
  }
});

// Bootstrap da aplicação
const bootstrap = async () => {
  try {
    await signInAnonymously(auth);
    
    // 1. Obter dados do usuário para checar ban/block
    const userSnap = await get(ref(db, `users/${currentUserUid}`));
    if(!userSnap.exists()){ logError({message: 'Dados de usuário não encontrados.'}); return; }
    
    const val = userSnap.val();
    if(await checkForceLogout(val)){ return; } // Se banido/deslogado, pára

    // 2. Setar Presença
    setPresence(true); 

    // 3. Checar Admin
    await checkAdmin();

    statusEl.textContent = 'Pronto';
  } catch (e) { logError(e); statusEl.textContent = 'Erro'; }
};
bootstrap();

// Logout
document.getElementById('logout').onclick = async (e) => {
  e.preventDefault();
  try {
    setPresence(false);
    await signOut(auth);
    localStorage.clear();
    location.href = 'index.html';
  } catch (e) { console.warn(e); }
};

</script>
</body>
</html>
